//
// Several functions for generating Swift code based on the parsed AST.
//
var ast = require('./SwiftAst');
function makeFile(file, globalAttrs, filename) {
    function decoderExists(typeName) {
        return globalAttrs.decoders.contains(typeName);
    }
    function encoderExists(typeName) {
        return globalAttrs.encoders.contains(typeName);
    }
    var structs = ast.structs(file, globalAttrs.typeAliases)
        .filter(function (s) { return !decoderExists(s.baseName) || !encoderExists(s.baseName); });
    var enums = ast.enums(file, globalAttrs.typeAliases)
        .filter(function (e) { return !decoderExists(e.baseName) || !encoderExists(e.baseName); });
    var lines = [];
    lines.push('//');
    lines.push('//  ' + filename);
    lines.push('//');
    lines.push('//  Auto generated by swift-json-gen on ' + new Date().toUTCString());
    lines.push('//  See for details: https://github.com/tomlokhorst/swift-json-gen');
    lines.push('//');
    lines.push('');
    lines.push('import Foundation');
    lines.push('');
    enums.forEach(function (s) {
        var createDecoder = !decoderExists(s.baseName);
        var createEncoder = !encoderExists(s.baseName);
        lines.push('extension ' + s.baseName + ' {');
        if (createDecoder) {
            lines = lines.concat(makeEnumDecoder(s));
        }
        if (createDecoder && createEncoder) {
            lines.push('');
        }
        if (createEncoder) {
            lines = lines.concat(makeEnumEncoder(s));
        }
        lines.push('}');
        lines.push('');
    });
    structs.forEach(function (s) {
        var createDecoder = !decoderExists(s.baseName);
        var createEncoder = !encoderExists(s.baseName);
        lines.push('extension ' + s.baseName + ' {');
        if (createDecoder) {
            lines = lines.concat(makeStructDecoder(s));
        }
        if (createDecoder && createEncoder) {
            lines.push('');
        }
        if (createEncoder) {
            lines = lines.concat(makeStructEncoder(s, enums));
        }
        lines.push('}');
        lines.push('');
    });
    return lines;
}
exports.makeFile = makeFile;
function makeEnumDecoder(en) {
    var lines = [];
    lines.push('  static func decodeJson(json: AnyObject) throws -> ' + en.baseName + ' {');
    lines.push('    guard let rawValue = json as? ' + en.rawTypeName + ' else {');
    lines.push('      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "' + en.rawTypeName + '")');
    lines.push('    }');
    lines.push('    guard let value = ' + en.baseName + '(rawValue: rawValue) else {');
    lines.push('      throw JsonDecodeError.WrongEnumRawValue(rawValue: rawValue, enumType: "' + en.baseName + '")');
    lines.push('    }');
    lines.push('');
    lines.push('    return value');
    lines.push('  }');
    return lines.join('\n');
}
function makeEnumEncoder(en) {
    var lines = [];
    lines.push('  func encodeJson() -> ' + en.rawTypeName + ' {');
    lines.push('    return rawValue');
    lines.push('  }');
    return lines.join('\n');
}
function makeStructDecoder(struct) {
    var lines = [];
    lines.push('  static func decodeJson' + decodeArguments(struct) + ' throws -> ' + struct.baseName + ' {');
    lines.push('    guard let dict = json as? [String : AnyObject] else {');
    lines.push('      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Dictionary")');
    lines.push('    }');
    lines.push('');
    lines.push('    var errors: [String: JsonDecodeError] = [:]');
    lines.push('');
    lines = lines.concat(makeFieldDeclarations(struct).map(indent(4)));
    lines.push('');
    struct.varDecls.forEach(function (d) {
        var subs = makeFieldDecode(d, struct.typeArguments).map(indent(4));
        lines = lines.concat(subs);
    });
    lines = lines.concat(makeReturn(struct).map(indent(4)));
    lines.push('  }');
    return lines.join('\n');
}
function makeStructEncoder(struct, enums) {
    var lines = [];
    lines.push('  func encodeJson' + encodeArguments(struct) + ' -> [String: AnyObject] {');
    lines.push('    var dict: [String: AnyObject] = [:]');
    lines.push('');
    struct.varDecls.forEach(function (d) {
        var subs = makeFieldEncode(d, struct.typeArguments, enums).map(indent(4));
        lines = lines.concat(subs);
    });
    lines.push('');
    lines.push('    return dict');
    lines.push('  }');
    return lines.join('\n');
}
function decodeArguments(struct) {
    var parts = struct.typeArguments
        .map(function (t) { return 'decode' + t + ': AnyObject throws -> ' + t; });
    parts.push('json: AnyObject');
    for (var i = 1; i < parts.length; i++) {
        parts[i] = '_ ' + parts[i];
    }
    return '(' + parts.join(', ') + ')';
}
function encodeArguments(struct) {
    var parts = struct.typeArguments
        .map(function (t) { return 'encode' + t + ': ' + t + ' -> AnyObject'; });
    for (var i = 1; i < parts.length; i++) {
        parts[i] = '_ ' + parts[i];
    }
    return '(' + parts.join(', ') + ')';
}
function indent(nr) {
    return function (s) {
        return s == '' ? s : Array(nr + 1).join(' ') + s;
    };
}
function isKnownType(type) {
    var types = ['AnyObject', 'AnyJson'];
    return types.contains(type.alias) || types.contains(type.baseName);
}
function isCastType(type) {
    var types = ['JsonObject', 'JsonArray'];
    return types.contains(type.alias) || types.contains(type.baseName);
}
function encodeFunction(name, type, genericEncoders) {
    if (isKnownType(type))
        return name;
    if (genericEncoders.contains(type.baseName))
        return 'encode' + type.baseName + '(' + name + ')';
    var args = type.genericArguments
        .map(function (t) { return '{ ' + encodeFunction('$0', t, genericEncoders) + ' }'; })
        .join(', ');
    return name + '.encodeJson(' + args + ')';
}
function makeFieldEncode(field, structTypeArguments, enums) {
    var lines = [];
    var name = field.name;
    var type = field.type;
    var prefix = '';
    if (type.baseName == 'Dictionary' && type.genericArguments.length == 2) {
        var keyType = type.genericArguments[0].baseName;
        var enum_ = enums.filter(function (e) { return e.baseName == keyType; })[0];
        if (keyType != 'String' && enum_.rawTypeName != 'String') {
            lines.push('/* WARNING: Json only supports Strings as keys in dictionaries */');
        }
    }
    lines.push('dict["' + name + '"] = ' + encodeFunction(name, type, structTypeArguments));
    return lines;
}
function decodeFunction(arg, type, genericDecoders) {
    var args = type.genericArguments
        .map(function (a) { return decodeFunctionArgument(a, genericDecoders); })
        .concat([arg])
        .join(', ');
    var typeName = type.alias || type.baseName;
    if (isKnownType(type))
        return '{ $0 as ' + typeName + ' }';
    if (isCastType(type))
        return '{ guard let result = $0 as? ' + typeName + ' else { throw JsonDecodeError.WrongType(rawValue: $0, expectedType: "' + typeName + '") }; return result }';
    if (genericDecoders.contains(typeName))
        return 'decode' + typeName + '(' + args + ')';
    return typeName + '.decodeJson(' + args + ')';
}
function decodeFunctionArgument(type, genericDecoders) {
    var typeName = type.alias || type.baseName;
    if (isKnownType(type))
        return '{ $0 as ' + typeName + ' }';
    if (isCastType(type))
        return '{ guard let result = $0 as? ' + typeName + ' else { throw JsonDecodeError.WrongType(rawValue: $0, expectedType: "' + typeName + '") }; return result }';
    return '{ try ' + decodeFunction('$0', type, genericDecoders) + ' }';
}
function typeToString(type) {
    if (type.genericArguments.length == 0)
        return type.baseName;
    if (type.baseName == 'Optional')
        return typeToString(type.genericArguments[0]) + '?';
    if (type.baseName == 'Array')
        return '[' + typeToString(type.genericArguments[0]) + ']';
    if (type.baseName == 'Dictionary')
        return '[' + typeToString(type.genericArguments[0]) + ' : ' + typeToString(type.genericArguments[1]) + ']';
    var args = type.genericArguments.map(typeToString).join(', ');
    return type.baseName + '<' + args + '>';
}
function makeFieldDeclarations(struct) {
    return struct.varDecls.map(function (decl) { return 'var ' + decl.name + '_optional: ' + typeToString(decl.type) + '?'; });
}
function makeFieldDecode(field, structTypeArguments) {
    var name = field.name;
    var type = field.type;
    var fieldName = name + '_field';
    var optionalName = name + '_optional';
    var typeString = typeToString(type);
    var lines = [];
    if (type.baseName == 'Optional') {
        lines.push('let ' + fieldName + ': AnyObject? = dict["' + name + '"]');
        lines.push('if let ' + fieldName + ' = ' + fieldName + ' where !(' + fieldName + ' is NSNull) {');
        lines.push('  do {');
        lines.push('    ' + optionalName + ' = try ' + decodeFunction(fieldName, type, structTypeArguments));
        lines.push('  }');
        lines.push('  catch let error as JsonDecodeError {');
        lines.push('    errors["' + name + '"] = error');
        lines.push('  }');
        lines.push('}');
        lines.push('else {');
        lines.push('  ' + optionalName + ' = .Some(nil)');
        lines.push('}');
    }
    else {
        lines.push('if let ' + fieldName + ': AnyObject = dict["' + name + '"] {');
        if (isKnownType(type)) {
            lines.push(optionalName + ' = ' + fieldName + ' as ' + typeString);
        }
        else if (isCastType(type)) {
            lines.push('  if let ' + fieldName + ' = ' + fieldName + ' as? ' + typeString + ' {');
            lines.push('    ' + optionalName + ' = ' + fieldName);
            lines.push('  }');
            lines.push('  else {');
            lines.push('    errors["' + name + '"] = JsonDecodeError.WrongType(rawValue: ' + fieldName + ', expectedType: "' + typeString + '")');
            lines.push('  }');
        }
        else {
            lines.push('  do {');
            lines.push('    ' + optionalName + ' = try ' + decodeFunction(fieldName, type, structTypeArguments));
            lines.push('  }');
            lines.push('  catch let error as JsonDecodeError {');
            lines.push('    errors["' + name + '"] = error');
            lines.push('  }');
        }
        lines.push('}');
        lines.push('else {');
        lines.push('  errors["' + name + '"] = JsonDecodeError.MissingValue');
        lines.push('}');
    }
    lines.push('');
    return lines;
}
function makeReturn(struct) {
    var lines = ['guard'];
    struct.varDecls.forEach(function (decl, index) {
        var isLast = index == struct.varDecls.length - 1;
        var suffix = isLast ? '' : ',';
        lines.push('  let ' + decl.name + ' = ' + decl.name + '_optional' + suffix);
    });
    lines.push('else {');
    lines.push('  throw JsonDecodeError.StructErrors(errors)');
    lines.push('}');
    var params = struct.varDecls.map(function (decl) { return decl.name + ': ' + decl.name; });
    lines.push('return ' + struct.baseName + '(' + params.join(', ') + ')');
    return lines;
}
